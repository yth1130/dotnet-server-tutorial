ServerCore : 서버 코어부분.
Server : 서버마다 달라지는 부분?
DummyClient : 더미 클라이언트.

---
멀티스레드 프로그래밍

1.개론
프로그램(프로세스)은 개별 식당.
cpu코어가 식당 종업원처럼 일함.
cpu코어를 여러개 두어 종업원이 여러명 일하는 것처럼 사용.
한 프로세스 내에서
Heap 영역(new)과 데이터 영역(static)은 스레드들이 공유해서 사용. 스택 영역은 공유하지 않는다.

쓰레드 생성
컴파일러 최적화
캐시 이론
메모리 배리어
Interlocked
Lock 기초
DeadLock
Lock구현 이론
SpinLock
Context Switching
AutoResetEvent
ReaderWriterLock
ReaderWriterLock 구현 연습
Thread Local Storage

---
네트워크 프로그래밍

1. 네트워크 기초
안정성. 해킹 공격에 대한 방어가 중요.

택배에 비유.
집에서 집으로 바로 보내지 않고 경비실에 맡긴다. 주소를 적어서. 단지 내라면 주소를 간략하게 이름으로 적어서 보낼 수도 있다.
다른 단지로 보내는 경우. 경비실을 경유해 택배 배송센터로 보내준다. 거기서 도착 단지의 경비실로 보낸다.

집은 단말기, 경비실은 스위치, 택배배송센터는 라우터.
같은 네트워크 안의 컴퓨터끼리의 통신은 라우터까지 가지 않고 네트워크 안에서 처리.
다른 네트워크로 보낼 때는 라우터를 거친다. ip주소를 사용.

2. 통신 모델

택배 보낼 물건
상품을 포장 
-> 배송 정책(단순 배달, 등기/수취인 확인 등) 
-> 주소 기입 
-> 단지 경로(바로 다음 목표. 계속 바뀜. (경비실 -> 배송 센터 -> 도착 경비실 -> 도착지))
-> 택배 운송

전송 데이터
어플리케이션(유저 인터페이스. HTTP, FTP, DNS 등. 주소로 도메인 사용.) 
-> 트랜스포트(전송 확인/오류 해결. TCP(꼼꼼하게 체크), UDP(퀵으로 빨리 보내지만 사후처리 없음))
-> 네트워크(네트워크 간 경로 설정. IPv4, IPv6 등. 관련 장치는 라우터(다른 단지. IP사용.))
-> 데이터 링크(네트워크 내의 경로 설정. 이더넷, PPP. 관련 장치는 스위치(같은 단지 내. MAC 사용. 기기마다 고유함.))
-> 피지컬(신호 처리. 케이블, 허브)
=> TCP/IP 모델. 다섯 계층이다. 밑에서부터 1계층.

OSI 7계층은 위의 TCP/IP모델에서 어플리케이션 부분이 세 계층으로 나뉘어져 있음. 어플리케이션, 프레젠테이션, 세션

3. 소켓 프로그래밍 입문 #1

식당관점
문지기 고용. 문지기 교육. 식당 주소를 알려준다. 정문에 있음. 핸드폰 하나를 쥐어준다.
손님에게 전화를 받고 대기열이 없으면 손님을 입장시킨다. 먼저온 한명(대리인)이 일행은 냅두고 들어와서 핸드폰을 받음. 일행이랑 통화함.

손님관점
핸드폰으로 식당 정문에 연락함. 입장가능한지 물어본다. 가능하다면 대리인을 보낸다. 대리인은 손님번호가 세팅된 핸드폰을 받는다. 손님과 연락.
손님은 대리인을 통해 식당과 연락.
????

이걸 소켓 프로그래밍으로 가져오면
핸드폰 -> 소켓
입장 문의 -> 서버 주소로 Connect
대리인 -> Session 소켓
통화 -> 패킷 송수신
서버에서 세션을 만들어주고 모든 통신은 세션을 통해 이뤄진다.

클라
핸드폰 준비 -> 소켓 준비
식당 번호로 입장 문의 -> 서버 주소로 Connect
휴대폰으로 대리인과 통화 -> 소켓을 통해 Session 소켓과 패킷 송수신

서버
문지기 고용 -> Listener 소켓 준비
문지기 교육 -> Bind(서버 주소/Port를 소켓에 연동)
영업 시작 -> Listen
안내 -> Accept

ServerCore는 실제 실행되는 프로젝트가 아니고 라이브러리의 형태로 사용됨.
출력 형식을 클래스 라이브러리로 바꿔줘야 함.
.csproj 파일에서 바꿔준다.

Server 프로젝트가 ServerCore를 참조하도록 바꿔준다.
dotnet add ./Server reference ./ServerCore
dotnet add ./DummyClient reference ./ServerCore

패킷을 주고받는다.

TCP : 배송 정책. 택배를 보내는 여러 단계에서 배송 정책에 해당.
보낼 때 순서 : 상품 - 배송 정책 - 최종 주소 - 단지 경로 - 택배 운송
받을 때 순서는 보낼 때의 역순.
어플리케이션 - 트랜스포트 - 네트워크 - 데이터 링크 - 피지컬
4단계인 트랜스포트 레이어에 해당.

TCP와 UDP의 차이
TCP는 
전화연결 방식(연결형 서비스. 연결을 위해 할당되는 논리적인 경로가 있다. 전송 순서가 보장된다!)
안전한 트럭(신뢰성 좋음. 분실이 일어나면 책임지고 다시 전송! 주고받을 상황이 아니면 일부만 보낸다(흐름/혼잡 제어)! 고려할 사항이 많아 속도는 (UDP에 비해서)별로)
UDP는 
우편 전송방식(비연결형 서비스. 연결이라는 개념이 없다. 전송 순서가 보장되지 않는다!)
위험한 총알배송(신뢰성 별로. 분실에 대한 책임 없음! 일단 보내고 생각! 단순하기 때문에 속도는 좋음)

FPS는 레이턴시가 중요.
이동패킷이 한두개 분실되어도 다음번에 제대로 받으면 문제 없음 -> UDP를 사용.
언리얼 데디케이트 서버도 UDP이다.
연결이 없기 때문에 모바일에서 인터넷이 잠깐 끊겨도 크게 문제 없음..

MMO는 보통 TCP를 사용.


직렬화(Serialization)ㄹ
패킷의 내용이 복잡할 때? 그때도 버퍼에 넣어야 되는데 그럴때 직렬화를 함.
세이브파일에도. 메모리상에있는 다양한 객체들(정보)를 파일로 만들 때. 바이트배열을 만들어 파일로 저장. -> 직렬화


아스키 코드. 1바이트로 표현. 0~127. 7비트 사용. 1비트는 통신에러 검출에 사용.
16진수 두자리로 표현. 0x41(65) 0x2F(47) ... 0x7F(127)

유니코드. 1바이트로 세상의 모든 문자를 표현하는것은 불가능. 2바이트(65535)정도면 충분하지 않을까?
3바이트짜리도 있음. 최대 3바이트.

UTF-8 인코딩. 영문 1바이트. 한글 3바이트.
UTF-16 인코딩. 추가 문자들 전까지는 2바이트 그 다음은 4바이트. 영문 2바이트. 한글 2바이트.
c#의 char는 2바이트. c++은 1바이트. 영문위주의 서비스에선 손해지만 일반적인 경우(한글, 한문 등) 이익.


커맨드 패턴
어떤 요청이 들어오면 바로 처리하는 것이 아니라 주문서를 만들어 전달하는 방식.
주문서에 담는걸 캡슐화한다고 한다.
주문이 오는것과 주문을 받아서 처리하는 시점을 둘로 분리할 수 있다.
주문을 취소하거나 바꿀 때 주문이 들어가기 전에 취소할 수 있다.